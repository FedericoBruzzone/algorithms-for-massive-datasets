\chapter{Introduction}\label{sect:introduction}
The problem of extending programming languages through new constructs has never lost interest both in the industry and in the research community. Modern general purpose programming languages are \textit{multiparadigm}, progressively converging towards a hybrid between object-orientation and functional programming. Languages from both the communities cross-pollinate each other with features. Languages that were born with pure object-orientation in mind nowadays tend to include functional constructs. This tendency to contamination between different programming styles can be read as the symptom of a need for more flexibility.

Traditionally, the design and implementation of a programming language is more of a \textit{top-down} activity, where most of the time is spent on the design of a consistent set of features; \textit{extensibility of the compiler}, although desirable, is not a strict requirement. But when today people speak about \textit{language development}, they often mean developing a new programming language with \textit{specific requirements} in mind. We could even dare to say that \textit{problem-tailored} programming language development is more of a \textit{bottom-up} activity, because, in some sense, the language specification \textit{rises} from the problem that the developers are trying to solve. Intuitively, a top-down design phase is still important, because it is important that the language consists of a coherent set of features; but in a domain-specific language (DSL), this phase can be often reduced to a minimum: even more so, if it were possible to implement new languages using off-the-shelf components.

A technique to implement languages is \textit{embedding}; this technique is part of the idiom of many modern programming languages such as Scala, Ruby, Groovy, which, in some sense, are following the lead of veterans such as LISP, the ``\textit{programmable programming language}''~\cite{Foderaro91}, and Smalltalk. \textit{Embedded} DSLs~\cite{Fowler10} are really just a byproduct of choosing a particular API design style, that Fowler and Evans dubbed a \textit{fluent interface}~\cite{Fowler05b}. Fluent APIs are often used to embed query languages within the body of a general purpose programming language (\textit{cf.,} Spring Data's Query DSL~\cite{Pollack12}) or to describe graphical user interfaces (\textit{cf.} JavaFX's APIs~\cite{Dea14}).
This technique has clear benefits: first of all it is easy to implement; second, it guarantees a high-degree of code reuse, because an embedded language is just a \textit{library}.
The main limit is that the expressivity of the language is inevitably dictated by the \textit{host} programming language. 
\textit{External DSLs}, on the other hand, are instead usually developed using dedicated toolsets, and work as stand-alone programming languages. The traditional route to external DSL development is to implement the front-end through parser generators such as good old \texttt{yacc}, ANTLR~\cite{Parr95} or, more recently, parser combinators~\cite{Swierstra00,Moors08}, and then implementing the semantics of the language. For this purpose, the variety of techniques ranges from attribute grammars~\cite{Knuth68,Paakki95} to simple syntax-directed translation~\cite{Aho86} to term-rewriting~\cite{Visser98}. The object of our research of the last few years has been geared towards realizing techniques and tools to implement \textit{componentized language implementations} with the final ``grand vision'' of a world where general-purpose and domain-specific programming languages can be realized by composing together \textit{linguistic features} the same way we combine together the pieces of a puzzle. And, just like each piece of a puzzle lives and exists on its own, each linguistic feature should be something that we can describe and implement in isolation and separately.

In fact, empiric evidence shows that many general-purpose languages share similar syntax and similar semantics for the same concepts: for instance, C-like programming languages such as C++, Java, C\# etc. all share a similar syntax for \texttt{for} loops,  \texttt{if} branches, variable declarations, and so on. The ultimate goal is to maximize reuse of syntactic and semantic definitions across different language implementations. To the point where end users may be even able to generate a language implementation by picking \textit{features} from a curated list: programming languages \textit{Ã  la carte}. 


\paragraph{Contribution}
Most of our experience in feature-oriented definition of programming languages have been carried out using our own framework, called Neverlang. Our contribution with this work is
\begin{enumerate}
   \item an abstract model for feature-oriented language implementation,
   \item a description of our implementation of this model in Neverlang 
   \item showing that the model can be supported by most of the existing tools for modular language implementation, 
   \item showing that the native implementation of this model strengthens the benefits of a modular language implementation.
\end{enumerate}

\paragraph{Organization}  Section~\ref{sect:background} gives a brief overview of the background information. Section~\ref{sect:conceptual} presents the abstract model. Section~\ref{sect:neverlang} introduces the Neverlang implementation of this model. Section~\ref{sect:casestudy} presents a full example (a state machine language). Section~\ref{sect:evaluation} is devoted to evaluate the model in a variety of contexts: the state machine language is re-implemented in other frameworks to show how the model can be reproduced; the benefits of using this model are then showed by describing the experience of extending Neverlang's JavaScript implementation \textsf{neverlang.js}; a DESK language implementation is briefly given to exemplify the expressive power of the Neverlang framework; finally, this section describes the experience of modeling \textit{variability} in programming language family, by automatically mining data from a collection of pre-implemented features.
Finally, Sect.~\ref{sect:related} briefly discusses related work and Sect.~\ref{sect:conclusions} draws the conclusions and describes the future work.
In~\ref{sect:formal} we have included a more formal description of the Neverlang model, that puts in relation the Neverlang implementation with the conceptual model of Sect.~\ref{sect:conceptual}.


